diff --git a/Makefile b/Makefile
index 09d790c..46f13f6 100644
--- a/Makefile
+++ b/Makefile
@@ -180,6 +180,7 @@ UPROGS=\
 	_stressfs\
 	_usertests\
 	_wc\
+	_lab1\
 	_zombie\
 
 fs.img: mkfs README $(UPROGS)
@@ -217,7 +218,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1 # Amending number of CPUs to 1 so only 1 CPU schedules processes instead of 2
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -249,8 +250,8 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c lab1.c zombie.c\
+	printf.c umalloc.c lab1.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff --git a/defs.h b/defs.h
index 82fb982..9e18250 100644
--- a/defs.h
+++ b/defs.h
@@ -120,6 +120,8 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int		info(int); // Add function prototype, will be implemented in proc.c
+int		print_proc(void); // temp function to print number of processes
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/proc.c b/proc.c
index 806b1b1..ecd0d67 100644
--- a/proc.c
+++ b/proc.c
@@ -88,6 +88,7 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->syscall = 0; // Initialize new proc with zero system calls
 
   release(&ptable.lock);
 
@@ -532,3 +533,82 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+/*
+ * Project 1 Specification:
+ * Add the int info(int) system call with allowed parameters 1, 2, 3
+ *
+*/
+int
+info(int n)
+{
+  if (n <= 0 || n >= 4) {
+    return -1; // need to call info with either 1, 2 or 3
+  }
+
+  struct proc *curproc = myproc();
+
+  // Enable interrupts
+  sti();
+
+  // Code to handle n = 1
+  if (n == 1) {
+    // Count the number of proccesses in the system
+    int numproc = 0;
+    struct proc *p;
+    acquire(&ptable.lock);
+    // Loop through the process table counting each process
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+      if (p->state != UNUSED)
+        ++numproc; // increment the process count
+    }
+    release(&ptable.lock);
+    return numproc;
+  }
+  
+  // Code to handle n = 2
+  if (n == 2) {
+    // We amended the code in syscall.c to increment the syscall counter in the per-process state, so simply return
+    return curproc->syscall;
+  }
+     
+  // Code to handle n = 3
+  if (n == 3) {
+    // Return the number of memory pages the current process is using
+    // the size of the proc / PGSIZE refers to the number of pages the process has mapped
+    return curproc->sz / PGSIZE;
+  }
+
+  // If we get here something went wrong
+  return -1;
+} 
+
+// Temp system call to print all processes in the system
+// Need to convert the proc state to a string
+const char * const procstring[] =
+{
+  [ZOMBIE] = "ZOMBIE",
+  [EMBRYO] = "EMBRYO",
+  [RUNNING] = "RUNNING",
+  [RUNNABLE] = "RUNNABLE",
+  [SLEEPING] = "SLEEPING",
+  [UNUSED] = "UNUSED"
+};
+
+int
+print_proc(void)
+{
+  struct proc* p;
+  sti();
+
+  // Loop through the process table and print stats
+  acquire(&ptable.lock);
+  cprintf("proc \t pid \t state \t \n");
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+    if (p->state != UNUSED)
+      cprintf("%s \t %d \t %s \t \n", p->name, p->pid , procstring[p->state]); 
+  }
+  release(&ptable.lock);
+
+  return 23; // Just the integer associated with the system call
+}  
diff --git a/proc.h b/proc.h
index 1647114..4794c92 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,7 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int syscall;		       // Keep in per-process state of number of system calls made
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..5007acd 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,9 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_info(void);
+extern int sys_print_proc(void);
+extern int sys_growproc(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,8 +129,12 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_info]    sys_info,
+[SYS_print_proc]  sys_print_proc,
+[SYS_growproc] sys_growproc,
 };
 
+// This is called whenever a process performs a system call
 void
 syscall(void)
 {
@@ -135,6 +142,9 @@ syscall(void)
   struct proc *curproc = myproc();
 
   num = curproc->tf->eax;
+  // Here we can increment our system call counter, as the process will execute this code whenever a system call is made
+  ++curproc->syscall;
+
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
     curproc->tf->eax = syscalls[num]();
   } else {
diff --git a/syscall.h b/syscall.h
index bc5f356..36acd14 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_info   22 // Adding new system call to the syscall library
+#define SYS_print_proc 23 // temp system call to print the number of processes there are
+#define SYS_growproc 24 // Adding system call to grow proc memory pages to illustrate memory page usage
+
diff --git a/sysproc.c b/sysproc.c
index 0686d29..03432f2 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,36 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+/* Depending on user value, returns:
+ * 1. count of proceses in the system
+ * 2. count of the total number of system calls that the current process has made so far
+ * 3. number of memory pages the current process is using
+ *
+*/
+int
+sys_info(void)
+{
+  int n;
+  if(argint(0, &n) < 0)
+    return -1;
+  return info(n);
+}
+
+// Temp print function
+int
+sys_print_proc(void)
+{
+  return print_proc();
+}
+
+// Growproc function
+int
+sys_growproc(void)
+{
+  int n;
+  if(argint(0, &n) < 0)
+    return -1;
+  growproc(n * PGSIZE);
+  return 0;
+} 
diff --git a/user.h b/user.h
index 4f99c52..c3cac64 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,9 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int info(int); // Adding prototype to user.h which defines functions available to users
+int print_proc(void);
+int growproc(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..c88ff67 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,6 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(info)
+SYSCALL(print_proc)
+SYSCALL(growproc)
